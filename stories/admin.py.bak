from django.contrib import admin
from django.utils.html import format_html
from .models import (
    Story, StoryLike, 
    Playlist, PlaylistItem, StoryView, StoryRecommendation,
    SearchQuery, UserRecommendation, UserWatchHistory
)

# YouTube-style комментарии будут зарегистрированы отдельно после миграций
from .comment_admin import *


@admin.register(Story)
class StoryAdmin(admin.ModelAdmin):
    list_display = [
        'title', 
        'category', 
        'views_count', 
        'is_featured', 
        'is_published', 
        'created_at',
        'youtube_preview'
    ]
    list_filter = [
        'is_published', 
        'is_featured', 
        'category', 
        'created_at'
    ]
    search_fields = ['title', 'description']
    prepopulated_fields = {'slug': ('title',)}
    filter_horizontal = ['tags']
    readonly_fields = ['views_count', 'youtube_embed_id', 'created_at', 'updated_at']
    
    fieldsets = (
        ('Основная информация', {
            'fields': ('title', 'slug', 'description')
        }),
        ('YouTube видео', {
            'fields': ('youtube_url', 'youtube_embed_id'),
            'description': 'Вставьте ссылку на YouTube видео. ID будет извлечен автоматически.'
        }),
        ('Категоризация', {
            'fields': ('category', 'tags')
        }),
        ('Настройки публикации', {
            'fields': ('is_published', 'is_featured')
        }),
        ('Статистика', {
            'fields': ('views_count', 'created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )

    def youtube_preview(self, obj):
        """Показывает превью YouTube видео в админке"""
        if obj.youtube_embed_id:
            embed_url = obj.get_youtube_embed_url()
            return format_html(
                '<iframe width="200" height="113" src="{}" frameborder="0" allowfullscreen></iframe>',
                embed_url
            )
        return "Видео не загружено"
    youtube_preview.short_description = "Превью видео"

    def save_model(self, request, obj, form, change):
        """Автоматически извлекает YouTube ID при сохранении"""
        if obj.youtube_url and not obj.youtube_embed_id:
            obj.youtube_embed_id = obj.extract_youtube_id(obj.youtube_url)
        super().save_model(request, obj, form, change)

    class Media:
        css = {
            'all': ('admin/css/stories_admin.css',)
        }


@admin.register(StoryLike)
class StoryLikeAdmin(admin.ModelAdmin):
    list_display = ['story', 'user', 'created_at']
    list_filter = ['created_at']
    search_fields = ['story__title', 'user__username']
    readonly_fields = ['created_at']
    
# Старые модели комментариев заменены новой YouTube-style системой
# Регистрация происходит в comment_admin.py через импорт


# ==========================================
# АДМИНКА ДЛЯ НОВЫХ МОДЕЛЕЙ ПЛЕЙЛИСТОВ
# ==========================================

class PlaylistItemInline(admin.TabularInline):
    """Инлайн для элементов плейлиста"""
    model = PlaylistItem
    extra = 0
    min_num = 0
    fields = ['story', 'order']
    ordering = ['order']
    autocomplete_fields = ['story']


@admin.register(Playlist)
class PlaylistAdmin(admin.ModelAdmin):
    list_display = [
        'title',  # Используем существующее поле
        'creator',  # Используем существующее поле
        'story_count_display',
        'playlist_type',  # Используем существующее поле
        'is_active',  # Используем существующее поле
        'views_count', 
        'created_at'
    ]
    list_filter = [
        'playlist_type',
        'is_active',
        'created_at',
        'creator'
    ]
    search_fields = ['title', 'description', 'creator__username']
    prepopulated_fields = {'slug': ('title',)}  # Правильное поле
    readonly_fields = ['views_count', 'created_at', 'updated_at']
    inlines = [PlaylistItemInline]
    
    fieldsets = (
        ('Основная информация', {
            'fields': ('title', 'slug', 'description', 'creator')
        }),
        ('Настройки', {
            'fields': ('playlist_type', 'is_active', 'cover_image')
        }),
        ('Статистика', {
            'fields': ('views_count', 'created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )
    
    def story_count_display(self, obj):
        """Показывает количество рассказов в плейлисте"""
        return obj.stories_count
    story_count_display.short_description = "Кол-во рассказов"
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related('creator')


@admin.register(PlaylistItem)
class PlaylistItemAdmin(admin.ModelAdmin):
    list_display = ['playlist', 'story', 'order', 'added_at']
    list_filter = ['playlist', 'added_at']
    search_fields = ['playlist__title', 'story__title']
    ordering = ['playlist', 'order']
    autocomplete_fields = ['playlist', 'story']
    readonly_fields = ['added_at']
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related('playlist', 'story')


@admin.register(StoryView)
class StoryViewAdmin(admin.ModelAdmin):
    list_display = [
        'story', 
        'user_display', 
        'ip_address', 
        'view_count', 
        'first_viewed',
        'last_viewed'
    ]
    list_filter = [
        'first_viewed',
        'last_viewed', 
        'story'
    ]
    search_fields = ['story__title', 'user__username', 'ip_address']
    readonly_fields = ['first_viewed', 'last_viewed']
    date_hierarchy = 'first_viewed'
    
    def user_display(self, obj):
        """Показывает пользователя или IP"""
        return obj.user.username if obj.user else f"IP: {obj.ip_address}"
    user_display.short_description = "Пользователь"
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related('story', 'user')


@admin.register(StoryRecommendation)
class StoryRecommendationAdmin(admin.ModelAdmin):
    list_display = [
        'source_story', 
        'recommended_story', 
        'similarity_score',
        'recommendation_type',
        'created_at'
    ]
    list_filter = [
        'recommendation_type',
        'created_at',
        'similarity_score'
    ]
    search_fields = [
        'source_story__title', 
        'recommended_story__title'
    ]
    readonly_fields = ['created_at']
    autocomplete_fields = ['source_story', 'recommended_story']
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related(
            'source_story', 
            'recommended_story'
        )


@admin.register(SearchQuery)
class SearchQueryAdmin(admin.ModelAdmin):
    list_display = ['query', 'count', 'last_searched', 'created_at']
    list_filter = ['last_searched', 'created_at']
    search_fields = ['query']
    readonly_fields = ['created_at', 'last_searched']
    ordering = ['-count', '-last_searched']


@admin.register(UserRecommendation)
class UserRecommendationAdmin(admin.ModelAdmin):
    list_display = [
        'user', 
        'story', 
        'score', 
        'reason', 
        'is_viewed',
        'created_at'
    ]
    list_filter = [
        'reason',
        'is_viewed', 
        'created_at'
    ]
    search_fields = ['user__username', 'story__title']
    readonly_fields = ['created_at']
    list_editable = ['is_viewed']
    autocomplete_fields = ['user', 'story']
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related('user', 'story')


@admin.register(UserWatchHistory)
class UserWatchHistoryAdmin(admin.ModelAdmin):
    list_display = [
        'user', 
        'story', 
        'watched_at',
        'watch_duration_display',
        'completed'
    ]
    list_filter = [
        'completed',
        'watched_at'
    ]
    search_fields = ['user__username', 'story__title']
    readonly_fields = ['watched_at']
    date_hierarchy = 'watched_at'
    autocomplete_fields = ['user', 'story']
    
    def watch_duration_display(self, obj):
        """Показывает длительность в читаемом формате"""
        minutes = obj.watch_duration // 60
        seconds = obj.watch_duration % 60
        return f"{minutes}:{seconds:02d}"
    watch_duration_display.short_description = "Длительность"
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related('user', 'story')
